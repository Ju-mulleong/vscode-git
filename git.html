버전 관리를 해야 하는 이유
    버그가 발생하였을때, 버전 관리를 하지 않았다면 일일이 모든 파일의 전수조사를 해야하지만, 버전관리를 하였다면 버전별로 실행하여 어떤 버전에서 버그가 발생하였는지 빠르게 파악할 수 있다. 

버전관리 시스템을 버전관리시스템답게 사용-디버깅

    그러려면, 중요한것이 두가지
        
    첫번쨰. 버전을 잘 만들어야한다 (하나의 버전안에 하나의 단위 작업) 각각의 버전은 원활한 설명을 위해 작업 내용이 잘 기술되어 있어야 한다.
        
    두번쨰,원하는 버전으로 언제든지 이동할수 있는 능력
    -> HEAD를 원하는 버전의 commit id 로 이동시키면 된다!
        git checkout 사용 commit id의 일부분만 써도 된다

    HEAD는 현재 directoty와 staging area가 보여주는 버전을 알려주는 것. 
    Main(Master)은 내가 가장 최근에 편집한 버전을 알려주는 것
    
    !!commit message 반드시 쓰자!!

    Git Graph 에서 우클릭해서 checkout할수도 있다.
    !main에 checkout하는것과, main이 가리키는 9b350c97에 checkout 하는것은 다른 것이다!
    이것은 main의 파란색 테두리가 생기는지 아닌지로 구별할 수 있다. 

    #git log --oneline --all --graph
    를 터미널에 입력하여 직관적으로 git log 파악 가능


버전관리의 잡기술
    내가 변경한 파일들만 '변경 사항' 밑에 나타난다.

    변경 사항 밑에 파일을 직접 클릭하면 그 전버전과 비교해 볼 수 있다.

    파일 부분에 'M'은 수정한 파일이라는걸 나타낸다

    '변경 내용 취소'는 내가 작업한 변경사항을 되돌린다 

Git hub
    branch
        main = 로컬 저장소의 branch
        origin/main = 원격 저장소의 branch

        main 과 origin이 최신의 같은 커밋을 가리킨다
        =동기화가 끝났다.

        push = github로 파일 백업
        pull = github에서 로컬 저장소로 파일 복구
        
        또한 pull = fetch + merge

        협업 : 만약 2명의 사람이 같은 저장소의 파일을 수정하고 있다면
        
            민석이 먼저 원격 저장소에 commit 하고 push 했다면,  
            순구가 push를 할려면 먼저 원격 저장소에서 민석이 먼저 push해놓은 파일을 받아서 병합해야함(fetch-merge) 
            즉 민석이 먼저 push해놓은 파일을 pull 해서 받은뒤, 자신의 파일과 병합해서 push 해야됨.

            그렇게 하지 않으면 원격 저장소에서 reject 당함
            

        충돌 : 서로 다른 사람이 같은 파일의 같은 행을 수정한다면
            해당 파일에 head는 현재 브랜치의 내용표시하고, another-branch는 
            head가 아닌 다른 브랜치를 말한다 (origin?)
            충돌을 해결하는법 : 병합. 

            현재 변경 사항 수락
                로컬 환경에서 작성한 내용이 적용된다. 
            
            수신 변경 사항 수락
                원격 저장소에서 가져온 내용이 적용된다. 
            
            두 변경 사항 모두 수락
                로컬 환경에서 작성한 내용과 원격 저장소에서 가져온 내용이 모두 적용된다. 

            또는 '같은 행' 인것이 문제이므로 줄바꿈으로 간단히 해결
